В этой задаче вам предлагается реализовать аналог еще одного из часто используемых классов стандартной библиотеки - умного указателя с разделяемым владением, а именно shared_ptr, и сопутствующих ему классов.

Напишите шаблонный класс SharedPtr<T> - упрощенный аналог std::shared_ptr<T> из C++11. Должны быть реализованы следующие методы (за подробным описанием того, что должны делать эти методы, можно обращаться к cppreference):

Конструктор от C-style указателя. Должно быть можно сконструироваться как от указателя на T, так и от указателя на наследника T.
Конструктор копирования, конструктор перемещения, операторы присваивания, деструктор. Умный указатель на родителя должно быть можно проинициализировать умным указателем на наследника, к оператору присваивания это тоже относится.
Метод use_count, возвращающий количество SharedPtr’ов, указывающих на тот же объект сейчас.
Метод reset от C-style указателя.
Реализуйте также функции создания SharedPtr из аргументов конструктора T:

Функцию makeShared, которая бы позволяла создавать SharedPtr минуя вызов new, сразу из аргументов конструктора T. Эта функция должна лишь 1 раз обращаться к new. Не забудьте, что аргументы надо перемещать, а не копировать, если они были rvalue.
Функцию allocateShared, которая делает то же, что и makeShared, но использует данный аллокатор вместо обращения к new. Этот же аллокатор впоследствии должен быть использован для уничтожения и освобождения памяти как под сам объект, так и под внутренние сущности SharedPtr.
Кроме того, нужно поддержать нестандарный Deleter и нестандартный аллокатор:

Конструктор от (Y*, Deleter), где Y есть либо T, либо наследник T, а Deleter - это класс, в котором присутствует оператор ()(Y* ptr). Этот оператор должен быть вызван вместо уничтожения объекта под SharedPtr’ом (освобождение памяти из-под объекта в таком случае делать тоже не надо).
Конструктор от (Y*, Deleter, Alloc), где Alloc - пользовательский аллокатор. Этот аллокатор должен быть использован для создания и удаления всех тех внутренних сущностей в динамической памяти, которые нужны для работы самого SharedPtr. При этом Deleter должен работать как описано выше, то есть аллокатор не должен применяться к уничтожению и освобождению ptr.
Ни Deleter, ни Allocator не должны быть шаблонными параметрами самого класса shared_ptr. (Подсказка: используйте идиому type erasure, чтобы обращаться к ним из shared_ptr).
Если при смерти SharedPtr<T> обнаруживает, что нужно уничтожить объект, но объект был типа U, где U - наследник T, то нужно это учесть. Объект должен быть уничтожен как U, а не как T.
Использовать функции makeShared или allocateShared с нестандартным Deleter нельзя. Также не нужно делать конструктор от (Y*, Alloc) без нестандартного Deleter.
Реализуйте также класс WeakPtr<T>. Должно быть поддержано следующее:

Конструктор от SharedPtr<U>, где U - либо T, либо наследник T.
Конструкторы копирования и перемещения, деструктор, операторы присваивания. Умный указатель на родителя должно быть можно проинициализировать умным указателем на наследника, к оператору присваивания это тоже относится.
Метод expired для проверки, не сдох ли еще объект под этим указателем.
Метод lock для получения SharedPtr на объект под данным WeakPtr’ом, если этот объект еще не сдох. (Для этого вам придется написать специальный приватный конструктор SharedPtr’а.)